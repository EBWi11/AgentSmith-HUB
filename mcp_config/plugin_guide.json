{
  "version": "2024-12-19",
  "description": "AgentSmith-HUB Plugin Development Guide and Templates",
  "plugin_creation_guide": {
    "name": "plugin_creation_complete_guide",
    "description": "Complete comprehensive guide for AgentSmith-HUB plugin development",
    "template": "AGENTSMITH-HUB PLUGIN DEVELOPMENT COMPLETE GUIDE\n\n=== PLUGIN TYPES ===\n\n1. CHECK PLUGINS (Return bool)\n   - Function signature: func Eval(args ...interface{}) (bool, error)\n   - Usage: <check type=\"PLUGIN\">myPlugin(field_name)</check>\n   - Purpose: Conditional checks in rules\n\n2. DATA PROCESSING PLUGINS (Return interface{})\n   - Function signature: func Eval(args ...interface{}) (interface{}, bool, error)\n   - Usage: <append type=\"PLUGIN\" field=\"result\">myPlugin(data)</append>\n   - Purpose: Data transformation and enrichment\n\n=== PLUGIN PARAMETERS ===\n\n**Parameter Types:**\n- Field reference: field_name (no _$ prefix needed)\n- Original data: _$ORIDATA (only this needs _$ prefix)\n- String: \"value\" or 'value'\n- Number: 123 or 123.45\n- Boolean: true or false\n\n**Examples:**\n```xml\n<check type=\"PLUGIN\">isPrivateIP(source_ip)</check>\n<append type=\"PLUGIN\" field=\"hash\">hashSHA256(file_content)</append>\n<plugin>sendAlert(_$ORIDATA)</plugin>\n```\n\n=== FUNCTION SIGNATURES ===\n\n**Check Plugin Template:**\n```go\npackage plugin\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc Eval(args ...interface{}) (bool, error) {\n    if len(args) == 0 {\n        return false, errors.New(\"plugin requires at least one argument\")\n    }\n    \n    // Parameter validation\n    data, ok := args[0].(string)\n    if !ok {\n        return false, errors.New(\"first argument must be string\")\n    }\n    \n    // Your logic here\n    if someCondition {\n        return true, nil\n    }\n    \n    return false, nil\n}\n```\n\n**Data Processing Plugin Template:**\n```go\npackage plugin\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc Eval(args ...interface{}) (interface{}, bool, error) {\n    if len(args) == 0 {\n        return nil, false, errors.New(\"plugin requires at least one argument\")\n    }\n    \n    // Parameter validation\n    input := args[0]\n    \n    // Your processing logic here\n    result := processData(input)\n    \n    return result, true, nil\n}\n```\n\n=== YAEGI PLUGIN FEATURES ===\n\n**State Management:**\n```go\n// Global state variables\nvar (\n    cache = make(map[string]interface{})\n    cacheMutex sync.RWMutex\n    lastUpdate time.Time\n)\n\n// Init function (executed when plugin loads)\nfunc init() {\n    // Initialize cache\n    refreshCache()\n    \n    // Start background tasks\n    go func() {\n        ticker := time.NewTicker(5 * time.Minute)\n        for range ticker.C {\n            refreshCache()\n        }\n    }()\n}\n\n// Stateful Eval function\nfunc Eval(key string) (interface{}, bool, error) {\n    cacheMutex.RLock()\n    if value, exists := cache[key]; exists {\n        cacheMutex.RUnlock()\n        return value, true, nil\n    }\n    cacheMutex.RUnlock()\n    \n    // Compute and cache result\n    result := computeResult(key)\n    cacheMutex.Lock()\n    cache[key] = result\n    cacheMutex.Unlock()\n    \n    return result, true, nil\n}\n```\n\n=== ALLOWED STANDARD LIBRARIES ===\n\n**Core Libraries:**\n- fmt, strings, strconv, errors\n- encoding/json, encoding/base64, encoding/hex\n- crypto/md5, crypto/sha256, crypto/rand\n- time, regexp\n- net, net/url\n- sync (for concurrency)\n\n**Forbidden:**\n- Any third-party packages\n- External dependencies\n\n=== COMMON PATTERNS ===\n\n**1. Cache Pattern:**\n```go\nvar cache = make(map[string]interface{})\nvar mutex sync.RWMutex\n\nfunc Eval(key string) (interface{}, bool, error) {\n    mutex.RLock()\n    if value, exists := cache[key]; exists {\n        mutex.RUnlock()\n        return value, true, nil\n    }\n    mutex.RUnlock()\n    \n    result := expensiveCalculation(key)\n    mutex.Lock()\n    cache[key] = result\n    mutex.Unlock()\n    \n    return result, true, nil\n}\n```\n\n**2. Counter Pattern:**\n```go\nvar counters = make(map[string]int)\nvar counterMutex sync.RWMutex\n\nfunc Eval(key string, threshold int) (bool, error) {\n    counterMutex.Lock()\n    defer counterMutex.Unlock()\n    \n    counters[key]++\n    return counters[key] > threshold, nil\n}\n```\n\n**3. Time Window Pattern:**\n```go\nvar (\n    lastSeen = make(map[string]time.Time)\n    timeMutex sync.RWMutex\n    window = 5 * time.Minute\n)\n\nfunc Eval(key string) (bool, error) {\n    now := time.Now()\n    \n    timeMutex.Lock()\n    defer timeMutex.Unlock()\n    \n    if last, exists := lastSeen[key]; exists {\n        if now.Sub(last) < window {\n            return false, nil\n        }\n    }\n    \n    lastSeen[key] = now\n    return true, nil\n}\n```\n\n=== ERROR HANDLING ===\n\n**Best Practices:**\n1. Always validate parameters first\n2. Return meaningful error messages\n3. Handle edge cases gracefully\n4. Use panic recovery for unexpected errors\n\n**Example:**\n```go\nfunc Eval(args ...interface{}) (interface{}, bool, error) {\n    defer func() {\n        if r := recover(); r != nil {\n            // Log panic and return error\n            return nil, false, fmt.Errorf(\"plugin panicked: %v\", r)\n        }\n    }()\n    \n    if len(args) == 0 {\n        return nil, false, errors.New(\"plugin requires at least one argument\")\n    }\n    \n    // Your logic here\n    return result, true, nil\n}\n```\n\n=== PERFORMANCE CONSIDERATIONS ===\n\n**Optimization Tips:**\n1. Use caching for expensive operations\n2. Implement lazy evaluation\n3. Use appropriate data structures\n4. Avoid unnecessary allocations\n5. Consider concurrency for I/O operations\n\n=== TESTING PLUGINS ===\n\n**Test Commands:**\n```bash\n# Test plugin with sample data\ntest_lab test_target='plugin' component_id='my_plugin' custom_data='[\"test_value\"]'\n\n# Validate plugin syntax\ncomponent_wizard component_type='plugin' component_id='my_plugin' validate_only='true'\n```\n\n=== DEPLOYMENT ===\n\n**Plugin Lifecycle:**\n1. Create plugin file (.go)\n2. Validate syntax and dependencies\n3. Load into system\n4. Use in rulesets\n5. Monitor performance and errors\n\n**Common Issues:**\n- Package name must be 'plugin'\n- Function must be named 'Eval'\n- Return type must match exactly\n- No external dependencies allowed\n\n=== REAL-WORLD EXAMPLES ===\n\n**1. IP Reputation Check:**\n```go\npackage plugin\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\nvar (\n    reputationCache = make(map[string]bool)\n    cacheMutex sync.RWMutex\n    lastRefresh time.Time\n)\n\nfunc init() {\n    refreshReputationData()\n}\n\nfunc Eval(ip string) (bool, error) {\n    if time.Since(lastRefresh) > 10*time.Minute {\n        refreshReputationData()\n    }\n    \n    cacheMutex.RLock()\n    isMalicious, exists := reputationCache[ip]\n    cacheMutex.RUnlock()\n    \n    if !exists {\n        return false, nil\n    }\n    \n    return isMalicious, nil\n}\n\nfunc refreshReputationData() {\n    // Implementation for refreshing reputation data\n}\n```\n\n**2. Rate Limiting Plugin:**\n```go\npackage plugin\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\nvar (\n    requestCounts = make(map[string]int)\n    lastReset = make(map[string]time.Time)\n    mutex sync.RWMutex\n)\n\nfunc Eval(userID string, limit int, windowSeconds int) (bool, error) {\n    now := time.Now()\n    \n    mutex.Lock()\n    defer mutex.Unlock()\n    \n    last, exists := lastReset[userID]\n    if !exists || now.Sub(last) > time.Duration(windowSeconds)*time.Second {\n        requestCounts[userID] = 0\n        lastReset[userID] = now\n    }\n    \n    requestCounts[userID]++\n    return requestCounts[userID] > limit, nil\n}\n```\n\n=== MANDATORY REQUIREMENTS ===\n\n⚠️ **CRITICAL RULES:**\n- Package name MUST be 'plugin'\n- Function name MUST be 'Eval'\n- Check plugins: return (bool, error)\n- Data plugins: return (interface{}, bool, error)\n- No external packages allowed\n- Always validate parameters\n- Handle errors gracefully\n\n=== COMMON MISTAKES ===\n\n❌ **Wrong package name:**\n```go\npackage myplugin  // WRONG\n```\n\n❌ **Wrong function name:**\n```go\nfunc Process(args ...interface{}) (bool, error)  // WRONG\n```\n\n❌ **External dependencies:**\n```go\nimport \"github.com/some/package\"  // WRONG\n```\n\n❌ **No parameter validation:**\n```go\nfunc Eval(args ...interface{}) (bool, error) {\n    data := args[0]  // WRONG - no validation\n    // ...\n}\n```\n\n✅ **Correct implementation:**\n```go\npackage plugin\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc Eval(args ...interface{}) (bool, error) {\n    if len(args) == 0 {\n        return false, errors.New(\"plugin requires at least one argument\")\n    }\n    \n    data, ok := args[0].(string)\n    if !ok {\n        return false, errors.New(\"first argument must be string\")\n    }\n    \n    // Your logic here\n    return true, nil\n}\n```\n\nThis guide provides comprehensive information for developing plugins in AgentSmith-HUB."
  },
  "plugin_quick_reference": {
    "name": "plugin_quick_reference",
    "description": "Quick reference for plugin development - key syntax and requirements only",
    "template": "AGENTSMITH-HUB PLUGIN QUICK REFERENCE\n\n=== MANDATORY REQUIREMENTS ===\n⚠️ Package name: 'plugin'\n⚠️ Function name: 'Eval'\n⚠️ Check plugin: return (bool, error)\n⚠️ Data plugin: return (interface{}, bool, error)\n⚠️ No external packages allowed\n\n=== FUNCTION SIGNATURES ===\n\n**Check Plugin:**\n```go\nfunc Eval(args ...interface{}) (bool, error)\n```\n\n**Data Plugin:**\n```go\nfunc Eval(args ...interface{}) (interface{}, bool, error)\n```\n\n=== PARAMETER TYPES ===\n- Field reference: field_name\n- Original data: _$ORIDATA\n- String: \"value\"\n- Number: 123\n- Boolean: true\n\n=== USAGE EXAMPLES ===\n```xml\n<check type=\"PLUGIN\">myCheckPlugin(source_ip)</check>\n<append type=\"PLUGIN\" field=\"result\">myDataPlugin(data)</append>\n<plugin>myActionPlugin(_$ORIDATA)</plugin>\n```\n\n=== ALLOWED IMPORTS ===\n- fmt, strings, strconv, errors\n- encoding/json, encoding/base64\n- crypto/md5, crypto/sha256\n- time, regexp, net, sync\n\n=== COMMON PATTERNS ===\n\n**Cache Pattern:**\n```go\nvar cache = make(map[string]interface{})\nvar mutex sync.RWMutex\n\nfunc Eval(key string) (interface{}, bool, error) {\n    mutex.RLock()\n    if value, exists := cache[key]; exists {\n        mutex.RUnlock()\n        return value, true, nil\n    }\n    mutex.RUnlock()\n    \n    result := compute(key)\n    mutex.Lock()\n    cache[key] = result\n    mutex.Unlock()\n    \n    return result, true, nil\n}\n```\n\n**Counter Pattern:**\n```go\nvar counters = make(map[string]int)\nvar mutex sync.RWMutex\n\nfunc Eval(key string, limit int) (bool, error) {\n    mutex.Lock()\n    defer mutex.Unlock()\n    \n    counters[key]++\n    return counters[key] > limit, nil\n}\n```\n\n=== ERROR HANDLING ===\n```go\nfunc Eval(args ...interface{}) (interface{}, bool, error) {\n    if len(args) == 0 {\n        return nil, false, errors.New(\"requires at least one argument\")\n    }\n    \n    // Your logic here\n    return result, true, nil\n}\n```\n\n=== TESTING ===\n```bash\ntest_lab test_target='plugin' component_id='my_plugin' custom_data='[\"test\"]'\n```\n\nUse complete guide for detailed examples and advanced patterns."
  },
  "plugin_creation_wizard": {
    "name": "plugin_creation_wizard",
    "description": "Interactive wizard for creating plugins with guided development",
    "template": "🚀 AGENTSMITH-HUB PLUGIN CREATION WIZARD 🚀\n\n=== WELCOME TO PLUGIN DEVELOPMENT ===\n\nI'll help you create a custom plugin for AgentSmith-HUB! Let's build something amazing together.\n\n=== WHAT KIND OF PLUGIN DO YOU NEED? ===\n\n**1. Check Plugin** - Returns true/false for conditions\n- Example: Check if IP is malicious, user is suspicious, etc.\n- Usage: <check type=\"PLUGIN\">myPlugin(field_name)</check>\n\n**2. Data Processing Plugin** - Transforms or enriches data\n- Example: Calculate risk score, parse complex data, etc.\n- Usage: <append type=\"PLUGIN\" field=\"result\">myPlugin(data)</append>\n\n**3. Action Plugin** - Performs external actions\n- Example: Send alerts, block IPs, log events, etc.\n- Usage: <plugin>myPlugin(_$ORIDATA)</plugin>\n\n=== LET'S START - TELL ME WHAT YOU WANT ===\n\n**Step 1: Describe your plugin's purpose**\nJust tell me what you want it to do:\n- \"Check if an IP address is in a blacklist\"\n- \"Calculate a risk score based on user behavior\"\n- \"Send alerts to Slack when threats are detected\"\n- \"Parse JSON data and extract specific fields\"\n\n**Step 2: Choose your plugin type**\n- Check plugin (returns bool)\n- Data processing plugin (returns any data)\n- Action plugin (performs actions)\n\n**Step 3: Describe your parameters**\nWhat data does your plugin need?\n- Field names from your data\n- Static values (strings, numbers)\n- The complete data object (_$ORIDATA)\n\n=== QUICK START COMMAND ===\n\n```\nplugin_wizard plugin_type='check|data|action' purpose='<what your plugin does>' parameters='<list of parameters>' auto_create='false'\n```\n\nExamples:\n```\nplugin_wizard plugin_type='check' purpose='check if IP is in blacklist' parameters='ip_address' auto_create='false'\n\nplugin_wizard plugin_type='data' purpose='calculate risk score' parameters='user_id,action_type,source_ip' auto_create='false'\n\nplugin_wizard plugin_type='action' purpose='send Slack alert' parameters='_$ORIDATA,webhook_url' auto_create='false'\n```\n\n=== WHAT HAPPENS NEXT? ===\n\n1. I'll analyze your requirements\n2. Generate the complete plugin code\n3. Show you exactly what will be created\n4. You can review and adjust before creating\n5. One command to deploy your plugin!\n\n=== COMMON PLUGIN IDEAS ===\n\n🔒 **Security Plugins:**\n- IP reputation checking\n- User behavior analysis\n- Threat intelligence lookup\n- Rate limiting\n- Anomaly detection\n\n📊 **Data Processing Plugins:**\n- Risk scoring algorithms\n- Data normalization\n- Complex parsing\n- Statistical analysis\n- Data enrichment\n\n🚨 **Action Plugins:**\n- Alert notifications (Slack, Teams, Discord)\n- IP blocking\n- Log forwarding\n- Database updates\n- API calls\n\n=== HANDS-ON EXAMPLE ===\n\nLet's create a simple IP blacklist checker:\n\n```\n# Step 1: Create the plugin\nplugin_wizard plugin_type='check' purpose='check if IP is in blacklist' parameters='ip_address' auto_create='true'\n\n# Step 2: Use it in a rule\n<check type=\"PLUGIN\">isBlacklisted(source_ip)</check>\n\n# Step 3: Test it\ntest_lab test_target='plugin' component_id='isBlacklisted' custom_data='[\"192.168.1.100\"]'\n```\n\n=== PLUGIN FEATURES ===\n\n✨ **What you can do:**\n- Access any field from your data\n- Perform complex calculations\n- Make HTTP requests\n- Use caching for performance\n- Maintain state between calls\n- Run background tasks\n- Handle errors gracefully\n\n⚡ **Performance features:**\n- Automatic caching\n- Concurrent execution\n- Memory management\n- Error recovery\n- Timeout protection\n\n=== NEED HELP? ===\n\n🆘 **If you get stuck:**\n- Ask: \"How do I create a plugin that...\"\n- Say: \"Help me build a plugin for...\"\n- Request: \"Show me an example of...\"\n\n💡 **Pro tips:**\n- Start simple, add complexity later\n- Test with real data\n- Use caching for expensive operations\n- Handle errors gracefully\n- Document your plugin's purpose\n\n=== READY? LET'S BUILD! ===\n\nTell me:\n1. What should your plugin do?\n2. What type of plugin do you need?\n3. What parameters does it need?\n\nI'll create the perfect plugin for you! 🚀"
  },
  "plugin_troubleshooting": {
    "name": "plugin_troubleshooting_guide",
    "description": "Troubleshooting guide for plugin development and deployment issues",
    "template": "🔧 AGENTSMITH-HUB PLUGIN TROUBLESHOOTING GUIDE 🔧\n\n=== COMMON PLUGIN ERRORS AND FIXES ===\n\n**1. \"Package name must be 'plugin'\" Error**\n```go\n// ❌ WRONG\npackage myplugin\n\n// ✅ CORRECT\npackage plugin\n```\n\n**2. \"Function name must be 'Eval'\" Error**\n```go\n// ❌ WRONG\nfunc Process(args ...interface{}) (bool, error)\n\n// ✅ CORRECT\nfunc Eval(args ...interface{}) (bool, error)\n```\n\n**3. \"Return type mismatch\" Error**\n```go\n// ❌ WRONG - Check plugin returning wrong type\nfunc Eval(args ...interface{}) (interface{}, error)\n\n// ✅ CORRECT - Check plugin\nfunc Eval(args ...interface{}) (bool, error)\n\n// ✅ CORRECT - Data plugin\nfunc Eval(args ...interface{}) (interface{}, bool, error)\n```\n\n**4. \"External package not allowed\" Error**\n```go\n// ❌ WRONG\nimport \"github.com/some/package\"\n\n// ✅ CORRECT - Only standard library\nimport (\n    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n```\n\n**5. \"Plugin not found\" Error**\n```bash\n# Check if plugin exists\nexplore_components component_type='plugin'\n\n# If missing, create it\ncomponent_wizard component_type='plugin' component_id='my_plugin' use_template='true'\n```\n\n**6. \"Plugin execution failed\" Error**\n```bash\n# Test plugin with sample data\ntest_lab test_target='plugin' component_id='my_plugin' custom_data='[\"test_value\"]'\n\n# Check plugin logs\nget_error_logs component_id='my_plugin' tail='50'\n```\n\n=== DEBUGGING TECHNIQUES ===\n\n**1. Add Debug Logging**\n```go\nfunc Eval(args ...interface{}) (interface{}, bool, error) {\n    fmt.Printf(\"Plugin called with args: %v\\n\", args)\n    \n    if len(args) == 0 {\n        return nil, false, errors.New(\"no arguments provided\")\n    }\n    \n    // Your logic here\n    result := processData(args[0])\n    fmt.Printf(\"Plugin result: %v\\n\", result)\n    \n    return result, true, nil\n}\n```\n\n**2. Parameter Validation**\n```go\nfunc Eval(args ...interface{}) (bool, error) {\n    // Validate argument count\n    if len(args) != 1 {\n        return false, fmt.Errorf(\"expected 1 argument, got %d\", len(args))\n    }\n    \n    // Validate argument type\n    ip, ok := args[0].(string)\n    if !ok {\n        return false, fmt.Errorf(\"expected string, got %T\", args[0])\n    }\n    \n    // Validate argument value\n    if ip == \"\" {\n        return false, errors.New(\"IP address cannot be empty\")\n    }\n    \n    // Your logic here\n    return true, nil\n}\n```\n\n**3. Error Recovery**\n```go\nfunc Eval(args ...interface{}) (interface{}, bool, error) {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Plugin panicked: %v\\n\", r)\n        }\n    }()\n    \n    // Your logic here\n    return result, true, nil\n}\n```\n\n=== PERFORMANCE ISSUES ===\n\n**1. Plugin Too Slow**\n```go\n// ❌ WRONG - No caching\nfunc Eval(ip string) (bool, error) {\n    // Expensive API call every time\n    return checkIPReputation(ip)\n}\n\n// ✅ CORRECT - With caching\nvar (\n    cache = make(map[string]bool)\n    mutex sync.RWMutex\n)\n\nfunc Eval(ip string) (bool, error) {\n    mutex.RLock()\n    if result, exists := cache[ip]; exists {\n        mutex.RUnlock()\n        return result, nil\n    }\n    mutex.RUnlock()\n    \n    result := checkIPReputation(ip)\n    mutex.Lock()\n    cache[ip] = result\n    mutex.Unlock()\n    \n    return result, nil\n}\n```\n\n**2. Memory Leaks**\n```go\n// ❌ WRONG - Unbounded cache growth\nvar cache = make(map[string]interface{})\n\n// ✅ CORRECT - Bounded cache\nvar (\n    cache = make(map[string]interface{})\n    mutex sync.RWMutex\n    maxSize = 1000\n)\n\nfunc Eval(key string) (interface{}, bool, error) {\n    mutex.Lock()\n    defer mutex.Unlock()\n    \n    if len(cache) >= maxSize {\n        // Clear cache when full\n        cache = make(map[string]interface{})\n    }\n    \n    // Your logic here\n    return result, true, nil\n}\n```\n\n=== TESTING STRATEGIES ===\n\n**1. Unit Testing**\n```bash\n# Test with various inputs\ntest_lab test_target='plugin' component_id='my_plugin' custom_data='[\"valid_input\"]'\ntest_lab test_target='plugin' component_id='my_plugin' custom_data='[\"\"]'\ntest_lab test_target='plugin' component_id='my_plugin' custom_data='[]'\n```\n\n**2. Integration Testing**\n```xml\n<!-- Test in actual rule -->\n<rule id=\"test_plugin\">\n  <check type=\"PLUGIN\">myPlugin(test_field)</check>\n  <append field=\"test_result\">myPlugin(test_data)</append>\n</rule>\n```\n\n**3. Load Testing**\n```bash\n# Test with high volume data\ntest_lab test_target='plugin' component_id='my_plugin' custom_data='[\"load_test\"]' performance_mode='true'\n```\n\n=== COMMON PATTERNS AND SOLUTIONS ===\n\n**1. HTTP Request Pattern**\n```go\nfunc Eval(url string) (interface{}, bool, error) {\n    client := &http.Client{Timeout: 10 * time.Second}\n    \n    resp, err := client.Get(url)\n    if err != nil {\n        return nil, false, fmt.Errorf(\"HTTP request failed: %v\", err)\n    }\n    defer resp.Body.Close()\n    \n    if resp.StatusCode != 200 {\n        return nil, false, fmt.Errorf(\"HTTP status: %d\", resp.StatusCode)\n    }\n    \n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return nil, false, fmt.Errorf(\"failed to read response: %v\", err)\n    }\n    \n    return string(body), true, nil\n}\n```\n\n**2. JSON Processing Pattern**\n```go\nfunc Eval(jsonStr string) (interface{}, bool, error) {\n    var data map[string]interface{}\n    \n    err := json.Unmarshal([]byte(jsonStr), &data)\n    if err != nil {\n        return nil, false, fmt.Errorf(\"JSON parsing failed: %v\", err)\n    }\n    \n    // Extract specific field\n    if value, exists := data[\"field_name\"]; exists {\n        return value, true, nil\n    }\n    \n    return nil, false, errors.New(\"field not found\")\n}\n```\n\n**3. Time-based Pattern**\n```go\nvar (\n    lastCheck = make(map[string]time.Time)\n    mutex sync.RWMutex\n    checkInterval = 5 * time.Minute\n)\n\nfunc Eval(key string) (bool, error) {\n    now := time.Now()\n    \n    mutex.Lock()\n    defer mutex.Unlock()\n    \n    if last, exists := lastCheck[key]; exists {\n        if now.Sub(last) < checkInterval {\n            return false, nil // Too soon to check again\n        }\n    }\n    \n    lastCheck[key] = now\n    return performCheck(key), nil\n}\n```\n\n=== DEPLOYMENT CHECKLIST ===\n\n□ Plugin package name is 'plugin'\n□ Function name is 'Eval'\n□ Return type matches plugin type\n□ No external dependencies\n□ Parameter validation implemented\n□ Error handling implemented\n□ Performance considerations addressed\n□ Plugin tested with sample data\n□ Plugin works in actual rules\n□ Documentation updated\n\n=== GETTING HELP ===\n\n**If you're still stuck:**\n\n1. **Check the logs:**\n   ```bash\n   get_error_logs component_id='my_plugin' tail='100'\n   ```\n\n2. **Test step by step:**\n   ```bash\n   test_lab test_target='plugin' component_id='my_plugin' custom_data='[\"simple_test\"]'\n   ```\n\n3. **Simplify the plugin:**\n   - Start with basic functionality\n   - Add complexity gradually\n   - Test each addition\n\n4. **Use the wizard:**\n   ```bash\n   plugin_wizard plugin_type='check' purpose='simple test' parameters='test_field' auto_create='true'\n   ```\n\nRemember: Most plugin issues are related to syntax, return types, or parameter validation. Start simple and build up! 🚀"
  }
} 