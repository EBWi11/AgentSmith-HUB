{
  "version": "2024-07-05",
  "prompts": [
    {
      "name": "rule_creation_data_compliance",
      "description": "Ensures rule creation strictly follows provided sample data without any imagination or assumption",
      "template": "üö® CRITICAL DATA COMPLIANCE FOR RULE CREATION üö®\n\nFUNDAMENTAL RULE: NEVER DEVIATE FROM PROVIDED DATA\n\n‚ùå ABSOLUTELY FORBIDDEN:\n- Creating rules without real sample data\n- Guessing or imagining field names\n- Using fake/example data like 'data_type=59'\n- Making up filter values or conditions\n- Assuming data structure without seeing actual data\n- Creating test_data by imagination\n- Using example values like 'msfconsole', 'chrome.exe' unless they appear in real data\n\n‚úÖ REQUIRED ACTIONS:\n1. ALWAYS try to get backend data first:\n   - Use get_samplers_data or get_samplers_data_intelligent\n   - These may FAIL if backend has no data\n\n2. If backend data fails:\n   - Do NOT proceed with rule creation\n   - Ask user to provide their own REAL sample data\n   - Wait for user to provide actual JSON from their systems\n\n3. Data analysis (once you have REAL data):\n   - Use ONLY field names that appear in actual data\n   - Base filter values ONLY on what exists in real data\n   - Test conditions with actual sample data provided\n\nüìå NOTE ON ProjectNodeSequence:\nEach sample carries \"projectNodeSequence\" ‚Äì the exact data-flow path (e.g. INPUT.kafka.RULESET.test.OUTPUT.p1).\nUse it to understand which project / component produced the sample.\nWhen rulesets are shared by multiple projects, sequence lets you tell them apart.\n\nüö® DATA SOURCES ARE LIMITED TO:\n1. MCP Server Response - from get_samplers_data tools\n2. User Provided Data - real JSON from user's systems\n3. NOTHING ELSE - AI cannot create any data\n\n‚ùå EXAMPLES OF FORBIDDEN BEHAVIOR:\n- test_data: {\"data_type\":59,\"exe\":\"msfconsole\"} (COMPLETELY IMAGINED)\n- test_data: {\"event_type\":\"network\",\"dest_ip\":\"8.8.8.8\"} (MADE UP)\n- Creating XML with field names not in actual data\n- Assuming field values without real examples\n\n‚úÖ CORRECT BEHAVIOR:\n- Call get_samplers_data first\n- If that fails: \"I need real sample data from your system. Please provide actual JSON data.\"\n- Wait for user to provide real data\n- Use ONLY fields and values from provided data"
    },
    {
      "name": "mcp_tool_selection",
      "description": "Guides users to appropriate MCP tools while enforcing strict data compliance",
      "template": "AgentSmith-HUB MCP Tool Selection Guide\n\nFor RULE CREATION (critical data compliance required):\n- get_samplers_data: Get real sample data\n- get_samplers_data_intelligent: Smart sample data with project context\n- rule_manager: Advanced rule creation with data validation\n- add_ruleset_rule: Direct rule addition (requires real test_data)\n\nWARNING: All rule creation tools require REAL sample data\n- NEVER create rules without actual data\n- NEVER use imagined field names or values\n- ALWAYS provide real test_data parameter\n\nDATA COMPLIANCE REMINDER:\nRule creation MUST be based on either:\n1. Backend data from get_samplers_data tools\n2. User-provided real JSON data\n\nNO OTHER DATA SOURCES ALLOWED"
    },
    {
      "name": "plugin_creation_requirements",
      "description": "Comprehensive guide for creating valid AgentSmith-HUB plugins with strict requirements compliance",
      "template": "üîß AGENTSMITH-HUB PLUGIN CREATION REQUIREMENTS üîß\n\nALL PLUGINS MUST FOLLOW THESE EXACT SPECIFICATIONS:\n\nüì¶ PACKAGE REQUIREMENTS:\n‚úÖ REQUIRED: package plugin\n‚ùå FORBIDDEN: Any other package name\n\nüìö IMPORT RESTRICTIONS:\n‚úÖ ALLOWED: Only Go standard library packages\n   - fmt, strings, strconv, errors, regexp\n   - time, math, encoding/json, crypto/*\n   - All standard library packages listed in validation\n‚ùå FORBIDDEN: External packages, third-party libraries\n\nüîß FUNCTION REQUIREMENTS:\n‚úÖ REQUIRED: Must contain 'Eval' function\n‚úÖ FUNCTION SIGNATURES (choose one):\n   1. For CheckNode plugins: func Eval(args ...interface{}) (bool, error)\n   2. For Other plugins: func Eval(args ...interface{}) (interface{}, bool, error)\n\nüéØ RETURN TYPE SPECIFICATIONS:\n- CheckNode plugins: Return (bool, error)\n  - bool: true if condition matches, false otherwise\n  - error: nil on success, error object on failure\n- General plugins: Return (interface{}, bool, error)\n  - interface{}: computed result (can be any type)\n  - bool: true if execution successful, false on logical failure\n  - error: nil on success, error object on execution failure\n\nüìù TEMPLATE STRUCTURE:\n```go\npackage plugin\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t// Only standard library imports allowed\n)\n\n// Function comment describing what the plugin does\nfunc Eval(args ...interface{}) (bool, error) {\n\t// Input validation\n\tif len(args) == 0 {\n\t\treturn false, errors.New(\"no arguments provided\")\n\t}\n\t\n\t// Your plugin logic here\n\t// Process args[0], args[1], etc.\n\t\n\t// Return result\n\treturn true, nil\n}\n```\n\n‚ö†Ô∏è VALIDATION CHECKLIST:\n1. Package declaration: package plugin ‚úì\n2. Eval function exists ‚úì\n3. Correct function signature ‚úì\n4. Only standard library imports ‚úì\n5. Proper error handling ‚úì\n6. Input argument validation ‚úì\n\nüö´ COMMON MISTAKES TO AVOID:\n- Wrong package name (package main, package utils, etc.)\n- Missing Eval function\n- Wrong function signature\n- Importing external libraries\n- Not handling errors properly\n- Not validating input arguments\n\nüí° BEST PRACTICES:\n- Always validate input arguments\n- Use descriptive variable names\n- Include helpful error messages\n- Test with various input types\n- Handle edge cases (empty strings, nil values)\n- Use standard library functions for common operations"
    },
    {
      "name": "plugin_parameter_handling",
      "description": "Guide for proper parameter handling in AgentSmith-HUB plugins",
      "template": "üîß PLUGIN PARAMETER HANDLING GUIDE üîß\n\nPROPER PARAMETER PROCESSING:\n\nüì• INPUT VALIDATION:\n```go\n// Always check argument count first\nif len(args) == 0 {\n    return false, errors.New(\"plugin requires at least one argument\")\n}\n\n// Type assertion with safety checks\ndata, ok := args[0].(string)\nif !ok {\n    return false, errors.New(\"first argument must be string\")\n}\n```\n\nüîÑ SPECIAL PARAMETERS:\n- _$ORIDATA: Original event data (map[string]interface{})\n- String literals: \"example_value\"\n- Field references: Direct field values\n- Numeric values: Converted to appropriate types\n\nüìä TYPE HANDLING:\n```go\n// Handle different parameter types\nfor i, arg := range args {\n    switch v := arg.(type) {\n    case string:\n        // Process string parameter\n    case map[string]interface{}:\n        // Process _$ORIDATA or complex data\n    case float64:\n        // Process numeric parameter\n    default:\n        // Convert to string as fallback\n        str := fmt.Sprintf(\"%v\", v)\n    }\n}\n```\n\n‚ö° PERFORMANCE TIPS:\n- Validate parameters early\n- Cache expensive computations\n- Use efficient string operations\n- Avoid unnecessary type conversions\n\nüéØ COMMON PATTERNS:\n1. Single data validation: Eval(data)\n2. Data with criteria: Eval(data, criteria)\n3. Multiple field check: Eval(data, field1, field2)\n4. Configuration-based: Eval(data, config_json)"
    }
  ],
  "rule_creation_warnings": {
    "pre_creation": "‚ö†Ô∏è Rule creation requires real sample data. Use get_samplers_data first or provide your own real data.",
    "data_validation": "‚úÖ Verify all field names and values exist in your actual data before creating rules.",
    "forbidden_actions": "‚ùå Never use imagined data like 'data_type=59' or 'exe=msfconsole' unless they appear in real samples."
  },
  "plugin_creation_warnings": {
    "pre_creation": "‚ö†Ô∏è Plugin creation must follow exact specifications. Package must be 'plugin', function must be 'Eval'.",
    "validation": "‚úÖ Verify package name, function signature, and import restrictions before creating plugins.",
    "forbidden_actions": "‚ùå Never use external packages, wrong function names, or incorrect return types."
  },
  "data_sources": {
    "allowed": [
      "MCP Server: get_samplers_data response",
      "MCP Server: get_samplers_data_intelligent response", 
      "User Provided: Real JSON from user's actual systems"
    ],
    "forbidden": [
      "AI imagination or assumptions",
      "Example/fake data creation",
      "Field name guessing",
      "Value fabrication"
    ]
  }
} 