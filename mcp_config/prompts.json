{
  "version": "2024-07-05",
  "prompts": [
    {
      "name": "rule_creation_data_compliance",
      "description": "Ensures rule creation strictly follows provided sample data without any imagination or assumption",
      "template": "CRITICAL DATA COMPLIANCE FOR RULE CREATION\n\nFUNDAMENTAL RULE: NEVER DEVIATE FROM PROVIDED DATA\n\nFORBIDDEN:\n- Creating rules without real sample data\n- Guessing or imagining field names\n- Using fake/example data like 'data_type=59'\n- Making up filter values or conditions\n- Assuming data structure without seeing actual data\n- Creating test_data by imagination\n- Using example values like 'msfconsole', 'chrome.exe' unless they appear in real data\n\nREQUIRED WORKFLOW:\n1. ALWAYS try to get backend data first:\n   - Use get_samplers_data or get_samplers_data_intelligent\n   - These may FAIL if backend has no data\n\n2. If backend data fails:\n   - Do NOT proceed with rule creation\n   - Ask user to provide their own REAL sample data\n   - Wait for user to provide actual JSON from their systems\n\n3. Data analysis (once you have REAL data):\n   - Use ONLY field names that appear in actual data\n   - Base filter values ONLY on what exists in real data\n   - Test conditions with actual sample data provided\n\nProjectNodeSequence shows the exact data-flow path (e.g. INPUT.kafka.RULESET.test.OUTPUT.p1). Use it to understand which project/component produced the sample.\n\nDATA SOURCES LIMITED TO:\n1. MCP Server Response - from get_samplers_data tools\n2. User Provided Data - real JSON from user's systems\n3. NOTHING ELSE - AI cannot create any data\n\nFORBIDDEN EXAMPLES:\n- test_data: {\"data_type\":59,\"exe\":\"msfconsole\"} (COMPLETELY IMAGINED)\n- test_data: {\"event_type\":\"network\",\"dest_ip\":\"8.8.8.8\"} (MADE UP)\n- Creating XML with field names not in actual data\n- Assuming field values without real examples\n\nCORRECT BEHAVIOR:\n- Call get_samplers_data first\n- If that fails: \"I need real sample data from your system. Please provide actual JSON data.\"\n- Wait for user to provide real data\n- Use ONLY fields and values from provided data"
    },
    {
      "name": "new_rule_syntax_guide",
      "description": "Guide for using the new flexible rule engine syntax with independent checks and optimized execution order",
      "template": "AGENTSMITH-HUB NEW RULE SYNTAX GUIDE\n\nKEY CHANGES:\n1. Operations now execute in the order they appear in XML\n2. Independent <check> tags don't need <checklist> wrapper\n3. Most selective checks should be placed first for performance\n\nBASIC STRUCTURE:\n```xml\n<rule id=\"rule_id\" name=\"Rule Name\">\n  <!-- Place most selective checks first -->\n  <check type=\"EQU\" field=\"event_type\">specific_type</check>\n  <check type=\"GT\" field=\"severity\">7</check>\n  \n  <!-- Use checklist ONLY for OR/NOT logic -->\n  <checklist logic=\"OR\">\n    <check type=\"EQU\" field=\"source\">A</check>\n    <check type=\"EQU\" field=\"source\">B</check>\n  </checklist>\n  \n  <!-- Operations execute where placed -->\n  <threshold group_by=\"user\" range=\"5m\" value=\"10\"/>\n  <append field=\"processed\">true</append>\n</rule>\n```\n\nIMPORTANT NOTES:\n- The old <node> tag is DEPRECATED - use <check> instead\n- The old <filter> tag is REMOVED - use <check> for all conditions\n- Simple AND logic doesn't need <checklist> anymore\n- Place expensive operations (REGEX, plugins) last\n\nPERFORMANCE OPTIMIZATION:\n- Order checks by selectivity (most filtering first)\n- Use exact matches before pattern matches\n- Place threshold operations after initial filtering"
    },
    {
      "name": "mcp_tool_selection",
      "description": "Guides users to appropriate MCP tools while enforcing strict data compliance",
      "template": "MCP TOOL SELECTION GUIDE\n\nFor RULE CREATION (critical data compliance required):\n- get_samplers_data: Get real sample data from backend\n- get_samplers_data_intelligent: Smart sample data with project context\n- rule_manager: Advanced rule creation with data validation\n- add_ruleset_rule: Direct rule addition (requires real test_data)\n\nWARNING: All rule creation tools require REAL sample data\n- NEVER create rules without actual data\n- NEVER use imagined field names or values\n- ALWAYS provide real test_data parameter\n\nDATA COMPLIANCE REMINDER:\nRule creation MUST be based on either:\n1. Backend data from get_samplers_data tools\n2. User-provided real JSON data\n\nNO OTHER DATA SOURCES ALLOWED"
    },
    {
      "name": "plugin_creation_requirements",
      "description": "Comprehensive guide for creating valid AgentSmith-HUB plugins with strict requirements compliance",
      "template": "AGENTSMITH-HUB PLUGIN CREATION REQUIREMENTS\n\nALL PLUGINS MUST FOLLOW THESE EXACT SPECIFICATIONS:\n\nPACKAGE REQUIREMENTS:\nREQUIRED: package plugin\nFORBIDDEN: Any other package name\n\nIMPORT RESTRICTIONS:\nALLOWED: Only Go standard library packages\n- fmt, strings, strconv, errors, regexp\n- time, math, encoding/json, crypto/*\n- All standard library packages listed in validation\nFORBIDDEN: External packages, third-party libraries\n\nFUNCTION REQUIREMENTS:\nREQUIRED: Must contain 'Eval' function\nFUNCTION SIGNATURES (choose one):\n1. For CheckNode plugins: func Eval(args ...interface{}) (bool, error)\n2. For Other plugins: func Eval(args ...interface{}) (interface{}, bool, error)\n\nRETURN TYPE SPECIFICATIONS:\n- CheckNode plugins: Return (bool, error)\n  - bool: true if condition matches, false otherwise\n  - error: nil on success, error object on failure\n- General plugins: Return (interface{}, bool, error)\n  - interface{}: computed result (can be any type)\n  - bool: true if execution successful, false on logical failure\n  - error: nil on success, error object on execution failure\n\nSTATE MANAGEMENT AND INIT FUNCTION:\nALLOWED: Plugins can maintain state and use init functions\n- Each plugin instance has its own yaegi interpreter\n- Global variables are allowed within the plugin\n- init() functions are executed when plugin loads\n- State persists between Eval() calls\n\nCONCURRENCY SAFETY:\nREQUIRED: Plugins must be thread-safe if maintaining state\n- Use sync.Mutex for protecting shared state\n- Consider concurrent access patterns\n- Stateless plugins are inherently safe\n\nEXAMPLE WITH STATE:\n```go\npackage plugin\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\t// Plugin state\n\tcounter int\n\tlastCall time.Time\n\tmu sync.Mutex\n)\n\nfunc init() {\n\t// Initialize plugin state\n\tcounter = 0\n\tlastCall = time.Now()\n}\n\nfunc Eval(args ...interface{}) (interface{}, bool, error) {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\t\n\tcounter++\n\tdelta := time.Since(lastCall)\n\tlastCall = time.Now()\n\t\n\treturn map[string]interface{}{\n\t\t\"count\": counter,\n\t\t\"delta_ms\": delta.Milliseconds(),\n\t}, true, nil\n}\n```\n\nTEMPLATE STRUCTURE:\n```go\npackage plugin\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t// Only standard library imports allowed\n)\n\n// Optional: Global state variables\nvar (\n\t// state variables here\n)\n\n// Optional: init function for initialization\nfunc init() {\n\t// initialization code here\n}\n\n// Function comment describing what the plugin does\nfunc Eval(args ...interface{}) (bool, error) {\n\t// Input validation\n\tif len(args) == 0 {\n\t\treturn false, errors.New(\"no arguments provided\")\n\t}\n\t\n\t// Your plugin logic here\n\t// Process args[0], args[1], etc.\n\t\n\t// Return result\n\treturn true, nil\n}\n```\n\nVALIDATION CHECKLIST:\n1. Package declaration: package plugin\n2. Eval function exists\n3. Correct function signature\n4. Only standard library imports\n5. Proper error handling\n6. Input argument validation\n7. Thread-safe if using state\n\nCOMMON MISTAKES TO AVOID:\n- Wrong package name (package main, package utils, etc.)\n- Missing Eval function\n- Wrong function signature\n- Importing external libraries\n- Not handling errors properly\n- Not validating input arguments\n- Race conditions in stateful plugins\n\nBEST PRACTICES:\n- Always validate input arguments\n- Use descriptive variable names\n- Include helpful error messages\n- Test with various input types\n- Handle edge cases (empty strings, nil values)\n- Use standard library functions for common operations\n- Protect shared state with mutexes\n- Consider making plugins stateless when possible"
    },
    {
      "name": "plugin_parameter_handling",
      "description": "Guide for proper parameter handling in AgentSmith-HUB plugins",
      "template": "PLUGIN PARAMETER HANDLING GUIDE\n\nPROPER PARAMETER PROCESSING:\n\nINPUT VALIDATION:\n```go\n// Always check argument count first\nif len(args) == 0 {\n    return false, errors.New(\"plugin requires at least one argument\")\n}\n\n// Type assertion with safety checks\ndata, ok := args[0].(string)\nif !ok {\n    return false, errors.New(\"first argument must be string\")\n}\n```\n\nSPECIAL PARAMETERS:\n- _$ORIDATA: Original event data (map[string]interface{})\n- String literals: \"example_value\"\n- Field references: Direct field values\n- Numeric values: Converted to appropriate types\n\nTYPE HANDLING:\n```go\n// Handle different parameter types\nfor i, arg := range args {\n    switch v := arg.(type) {\n    case string:\n        // Process string parameter\n    case map[string]interface{}:\n        // Process _$ORIDATA or complex data\n    case float64:\n        // Process numeric parameter\n    default:\n        // Convert to string as fallback\n        str := fmt.Sprintf(\"%v\", v)\n    }\n}\n```\n\nPERFORMANCE TIPS:\n- Validate parameters early\n- Cache expensive computations\n- Use efficient string operations\n- Avoid unnecessary type conversions\n\nCOMMON PATTERNS:\n1. Single data validation: Eval(data)\n2. Data with criteria: Eval(data, criteria)\n3. Multiple field check: Eval(data, field1, field2)\n4. Configuration-based: Eval(data, config_json)"
    },
    {
      "name": "rule_append_desc_requirement",
      "description": "Ensures every newly created rule contains an <append field=\"desc\"> element for downstream readability",
      "template": "RULE APPEND REQUIREMENT\n\nEvery rule MUST include an <append field=\"desc\"> element containing the rule description.\n\nExample:\n<append field=\"desc\">Detect suspicious bash reverse shell execution patterns</append>\n\nRULE_DESCRIPTION should replicate the rule's 'name' attribute (or a more user-friendly wording) so that alert pipelines and dashboards can display it without extra parsing."
    }
  ],
  "rule_creation_warnings": {
    "pre_creation": "Rule creation requires real sample data. Use get_samplers_data first or provide your own real data.",
    "data_validation": "Verify all field names and values exist in your actual data before creating rules.",
    "forbidden_actions": "Never use imagined data like 'data_type=59' or 'exe=msfconsole' unless they appear in real samples.",
    "syntax_update": "Use the new flexible syntax: independent <check> tags, execution order matters, <node> is deprecated."
  },
  "plugin_creation_warnings": {
    "pre_creation": "Plugin creation must follow exact specifications. Package must be 'plugin', function must be 'Eval'.",
    "validation": "Verify package name, function signature, and import restrictions before creating plugins.",
    "forbidden_actions": "Never use external packages, wrong function names, or incorrect return types."
  },
  "data_sources": {
    "allowed": [
      "MCP Server: get_samplers_data response",
      "MCP Server: get_samplers_data_intelligent response", 
      "User Provided: Real JSON from user's actual systems"
    ],
    "forbidden": [
      "AI imagination or assumptions",
      "Example/fake data creation",
      "Field name guessing",
      "Value fabrication"
    ]
  }
} 