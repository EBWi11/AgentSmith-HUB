{
  "prompts": [
    {
      "name": "rule_creation_data_compliance",
      "description": "Ensures rule creation strictly follows provided sample data without any imagination or assumption",
      "template": "üö® CRITICAL DATA COMPLIANCE FOR RULE CREATION üö®\n\nFUNDAMENTAL RULE: NEVER DEVIATE FROM PROVIDED DATA\n\n‚ùå ABSOLUTELY FORBIDDEN:\n- Creating rules without real sample data\n- Guessing or imagining field names\n- Using fake/example data like 'data_type=59'\n- Making up filter values or conditions\n- Assuming data structure without seeing actual data\n- Creating test_data by imagination\n- Using example values like 'msfconsole', 'chrome.exe' unless they appear in real data\n\n‚úÖ REQUIRED ACTIONS:\n1. ALWAYS try to get backend data first:\n   - Use get_samplers_data or get_samplers_data_intelligent\n   - These may FAIL if backend has no data\n\n2. If backend data fails:\n   - Do NOT proceed with rule creation\n   - Ask user to provide their own REAL sample data\n   - Wait for user to provide actual JSON from their systems\n\n3. Data analysis (once you have REAL data):\n   - Use ONLY field names that appear in actual data\n   - Base filter values ONLY on what exists in real data\n   - Test conditions with actual sample data provided\n\nüö® DATA SOURCES ARE LIMITED TO:\n1. MCP Server Response - from get_samplers_data tools\n2. User Provided Data - real JSON from user's systems\n3. NOTHING ELSE - AI cannot create any data\n\n‚ùå EXAMPLES OF FORBIDDEN BEHAVIOR:\n- test_data: {\"data_type\":59,\"exe\":\"msfconsole\"} (COMPLETELY IMAGINED)\n- test_data: {\"event_type\":\"network\",\"dest_ip\":\"8.8.8.8\"} (MADE UP)\n- Creating XML with field names not in actual data\n- Assuming field values without real examples\n\n‚úÖ CORRECT BEHAVIOR:\n- Call get_samplers_data first\n- If that fails: \"I need real sample data from your system. Please provide actual JSON data.\"\n- Wait for user to provide real data\n- Use ONLY fields and values from provided data"
    },
    {
      "name": "mcp_tool_selection",
      "description": "Guides users to appropriate MCP tools while enforcing strict data compliance",
      "template": "AgentSmith-HUB MCP Tool Selection Guide\n\nFor RULE CREATION (critical data compliance required):\n- get_samplers_data: Get real sample data\n- get_samplers_data_intelligent: Smart sample data with project context\n- rule_manager: Advanced rule creation with data validation\n- add_ruleset_rule: Direct rule addition (requires real test_data)\n\nWARNING: All rule creation tools require REAL sample data\n- NEVER create rules without actual data\n- NEVER use imagined field names or values\n- ALWAYS provide real test_data parameter\n\nDATA COMPLIANCE REMINDER:\nRule creation MUST be based on either:\n1. Backend data from get_samplers_data tools\n2. User-provided real JSON data\n\nNO OTHER DATA SOURCES ALLOWED"
    },
    {
      "name": "plugin_development_guide",
      "description": "Comprehensive guide for custom plugin development with strict requirements and best practices",
      "template": "üîß AGENTSMITH-HUB PLUGIN DEVELOPMENT GUIDE üîß\n\n=== MANDATORY REQUIREMENTS ===\n\nüì¶ **Package Declaration:**\n```go\npackage plugin  // REQUIRED - must be exactly 'plugin'\n```\n\nüîß **Function Signature (CRITICAL):**\nYour plugin MUST contain an 'Eval' function with one of these signatures:\n\n**For CheckNode plugins (boolean detection):**\n```go\nfunc Eval(data string) (bool, error)\nfunc Eval(ipStr string) (bool, error)\nfunc Eval(args ...interface{}) (bool, error)\n```\n\n**For Other plugins (data processing):**\n```go\nfunc Eval(oriData map[string]interface{}) (map[string]interface{}, error)\nfunc Eval(args ...interface{}) (interface{}, bool, error)\n```\n\nüìã **Parameter Guidelines:**\n- Use descriptive parameter names (e.g., 'ipStr', 'data', 'oriData')\n- Support variadic parameters with ...interface{} for flexibility\n- Document parameter types and purposes in comments\n\nüîÑ **Return Value Rules:**\n- CheckNode: (bool, error) - for ruleset condition checking\n- Data Processing: (interface{}, bool, error) - for data transformation\n- Always return error as the last value\n- Bool indicates success/failure in multi-return scenarios\n\nüìö **Import Restrictions:**\n- ONLY Go standard library packages allowed\n- Common useful packages: \"strings\", \"regexp\", \"fmt\", \"strconv\", \"time\"\n- NO external dependencies permitted\n\nüí° **Best Practices:**\n- Add comprehensive error handling\n- Use descriptive variable names\n- Include meaningful error messages\n- Test edge cases (empty strings, nil values)\n- Document complex logic with comments\n\n‚ö†Ô∏è **Common Mistakes to Avoid:**\n- Wrong package name (must be 'plugin')\n- Incorrect function name (must be 'Eval')\n- Wrong return type count or order\n- Using external dependencies\n- Missing error handling\n\nüß™ **Testing Your Plugin:**\n- Use 'test_plugin' MCP tool to validate\n- Test with various input types and edge cases\n- Verify return types match intended usage (checknode vs data processing)\n\nüìù **Example Templates:**\n\n**Simple String Check:**\n```go\npackage plugin\n\nimport \"strings\"\n\nfunc Eval(input string) (bool, error) {\n    if strings.TrimSpace(input) == \"\" {\n        return false, nil\n    }\n    return strings.Contains(input, \"suspicious\"), nil\n}\n```\n\n**Data Processing:**\n```go\npackage plugin\n\nimport \"fmt\"\n\nfunc Eval(data map[string]interface{}) (map[string]interface{}, error) {\n    if data == nil {\n        return nil, fmt.Errorf(\"input data cannot be nil\")\n    }\n    \n    // Process data\n    data[\"processed\"] = true\n    return data, nil\n}\n```"
    },
    {
      "name": "plugin_usage_guide",
      "description": "Guide for using plugins in rulesets with proper syntax and context awareness",
      "template": "üéØ PLUGIN USAGE IN RULESETS GUIDE üéØ\n\n=== PLUGIN INTEGRATION CONTEXTS ===\n\nüîç **CheckNode Context (Boolean Logic):**\nFor condition checking in <checklist>:\n```xml\n<node id=\"plugin_check\" type=\"PLUGIN\" field=\"data\">\n    plugin_name(_$ORIDATA)\n</node>\n```\n\n**Requirements:**\n- Plugin MUST return (bool, error)\n- Used for true/false decision making\n- Supports logical operators (and, or) with other nodes\n\nüìù **Append Context (Data Enhancement):**\nFor adding new fields:\n```xml\n<append field=\"new_field_name\" type=\"PLUGIN\">\n    plugin_name(\"param1\", field_reference)\n</append>\n```\n\n**Requirements:**\n- Plugin can return any type\n- Result becomes the value of the new field\n\nüîß **Standalone Plugin Context:**\nFor side effects and external actions:\n```xml\n<plugin>plugin_name(_$ORIDATA, \"additional_param\")</plugin>\n```\n\n**Requirements:**\n- Plugin can perform any action\n- Return value indicates success/failure\n\n=== PARAMETER SYNTAX ===\n\nüìä **Data References:**\n- `_$ORIDATA` - Complete original data object\n- `\"${field_name}\"` - Reference specific field value\n- `\"literal_string\"` - Static string parameter\n- `123` - Numeric literal\n- `true/false` - Boolean literal\n\nüîß **Parameter Examples:**\n```xml\n<!-- Pass complete data -->\nip_checker(_$ORIDATA)\n\n<!-- Pass specific field -->\nip_checker(\"${source_ip}\")\n\n<!-- Multiple parameters -->\nnotify_team(\"${alert_level}\", \"security@company.com\", _$ORIDATA)\n\n<!-- Mixed parameter types -->\nthreshold_check(\"${cpu_usage}\", 80, true)\n```\n\n‚ö†Ô∏è **Common Usage Errors:**\n\n‚ùå **Wrong Context Usage:**\n```xml\n<!-- DON'T: Use data-processing plugin in checknode -->\n<node type=\"PLUGIN\">data_transformer(_$ORIDATA)</node>\n```\n\n‚ùå **Invalid Parameter Syntax:**\n```xml\n<!-- DON'T: Missing quotes for field references -->\nplugin_name(${field_name})\n\n<!-- DON'T: Wrong data reference -->\nplugin_name($ORIDATA)\n```\n\n‚úÖ **Correct Usage:**\n```xml\n<!-- CheckNode: Boolean return for conditions -->\n<node id=\"security_check\" type=\"PLUGIN\">\n    is_malicious_ip(\"${source_ip}\")\n</node>\n\n<!-- Append: Add processed data -->\n<append field=\"geolocation\" type=\"PLUGIN\">\n    get_ip_location(\"${source_ip}\")\n</append>\n\n<!-- Standalone: Perform actions -->\n<plugin>send_alert(_$ORIDATA, \"high_priority\")</plugin>\n```\n\nüß™ **Testing Plugin Integration:**\n- Use 'validate_ruleset' to check syntax\n- Use 'test_ruleset' with sample data\n- Verify plugin parameters match function signature\n- Check return types match usage context"
    },
    {
      "name": "plugin_troubleshooting",
      "description": "Comprehensive troubleshooting guide for plugin development and integration issues",
      "template": "üîß PLUGIN TROUBLESHOOTING GUIDE üîß\n\n=== COMMON DEVELOPMENT ISSUES ===\n\n‚ùå **Compilation Errors:**\n\n**Issue: Package name error**\n```\nError: plugin package must be 'plugin', found: 'main'\n```\n**Solution:** Change `package main` to `package plugin`\n\n**Issue: Function not found**\n```\nError: plugin must contain an 'Eval' function\n```\n**Solution:** Ensure function is named exactly 'Eval' (case-sensitive)\n\n**Issue: Import restrictions**\n```\nError: plugin can only import Go standard library packages\n```\n**Solution:** Remove external dependencies, use only standard library\n\n‚ùå **Runtime Errors:**\n\n**Issue: Wrong return type count**\n```\nError: plugin returned unexpected number of results: 1\n```\n**Solution:** Ensure Eval function returns exactly 2 or 3 values:\n- CheckNode: (bool, error)\n- Data Processing: (interface{}, bool, error)\n\n**Issue: Type assertion failed**\n```\nError: plugin returned unexpected type\n```\n**Solution:** Verify return types match expected signature\n\n**Issue: Plugin execution panicked**\n```\nError: plugin execution panicked: runtime error\n```\n**Solution:** Add nil checks and error handling for edge cases\n\n=== INTEGRATION ISSUES ===\n\n‚ùå **Ruleset Integration:**\n\n**Issue: Plugin not found in ruleset**\n```\nError: not found this plugin: plugin_name\n```\n**Solution:** \n1. Check plugin is saved and deployed\n2. Use 'get_pending_changes' to verify deployment status\n3. Use 'apply_changes' if plugin is pending\n\n**Issue: Wrong plugin context usage**\n```\nError: Plugin 'data_processor' cannot be used in checknode\n```\n**Solution:** Use plugins with (bool, error) return in checknodes only\n\n**Issue: Parameter count mismatch**\n```\nError: Not enough arguments for plugin 'ip_checker'\n```\n**Solution:** Check plugin parameter requirements with 'get_plugin_parameters'\n\n=== DEBUGGING WORKFLOW ===\n\nüîç **Step 1: Verify Plugin Exists**\n```\n‚Üí get_plugins (list all plugins)\n‚Üí get_plugin with id=\"your_plugin_name\"\n```\n\nüîç **Step 2: Check Deployment Status**\n```\n‚Üí get_pending_changes (check if plugin needs deployment)\n‚Üí apply_changes (deploy if needed)\n```\n\nüîç **Step 3: Test Plugin Functionality**\n```\n‚Üí test_plugin with id=\"your_plugin_name\" and test data\n‚Üí Verify return types and error handling\n```\n\nüîç **Step 4: Validate Ruleset Integration**\n```\n‚Üí validate_ruleset (check syntax and plugin references)\n‚Üí test_ruleset with sample data\n```\n\n=== PARAMETER DEBUGGING ===\n\nüß™ **Check Plugin Signature:**\n```\n‚Üí get_plugin_parameters with id=\"plugin_name\"\n```\nThis shows:\n- Parameter names and types\n- Required vs optional parameters\n- Return type information\n\nüß™ **Parameter Type Validation:**\n- String parameters: Use quotes \"value\"\n- Field references: Use \"${field_name}\" syntax\n- Raw data: Use _$ORIDATA\n- Numbers: Use without quotes (123, 3.14)\n- Booleans: Use true/false without quotes\n\n=== PERFORMANCE ISSUES ===\n\n‚ö° **Plugin Optimization:**\n- Avoid complex regex in high-frequency checknode plugins\n- Cache expensive operations when possible\n- Use early returns for performance\n- Minimize memory allocations in loops\n\n‚ö° **Integration Optimization:**\n- Place efficient filters before expensive plugin checks\n- Use appropriate plugin contexts (checknode vs append vs standalone)\n- Consider plugin execution order in rulesets\n\n=== EMERGENCY FIXES ===\n\nüö® **Plugin Causing System Issues:**\n1. Check 'get_pending_changes' - revert if not deployed\n2. Edit plugin code to fix issues\n3. Test with 'test_plugin' before redeploying\n4. Use 'apply_changes' carefully with fixes\n\nüö® **Ruleset References Broken Plugin:**\n1. Temporarily disable ruleset\n2. Fix or remove plugin reference\n3. Re-enable ruleset after verification\n\nRemember: Always test plugins in isolation before integrating into production rulesets!"
    },
    {
      "name": "plugin_best_practices",
      "description": "Best practices and design patterns for robust, efficient, and maintainable AgentSmith-HUB plugins",
      "template": "‚≠ê PLUGIN DEVELOPMENT BEST PRACTICES ‚≠ê\n\n=== DESIGN PRINCIPLES ===\n\nüéØ **Single Responsibility:**\n- Each plugin should have one clear purpose\n- Avoid combining multiple unrelated checks\n- Name plugins descriptively (e.g., 'is_local_ip', 'extract_threat_score')\n\nüîí **Defensive Programming:**\n```go\nfunc Eval(input string) (bool, error) {\n    // Always validate inputs\n    if strings.TrimSpace(input) == \"\" {\n        return false, nil // Don't error on empty input\n    }\n    \n    // Handle edge cases gracefully\n    if len(input) > 1000 {\n        return false, fmt.Errorf(\"input too long: %d chars\", len(input))\n    }\n    \n    // Your logic here\n    return true, nil\n}\n```\n\n‚ö° **Performance Optimization:**\n```go\n// ‚úÖ GOOD: Early returns for performance\nfunc Eval(data string) (bool, error) {\n    if data == \"\" {\n        return false, nil // Fast path\n    }\n    \n    // Only do expensive operations when needed\n    if strings.Contains(data, \"critical_keyword\") {\n        return expensiveCheck(data), nil\n    }\n    \n    return false, nil\n}\n\n// ‚ùå BAD: Always doing expensive operations\nfunc Eval(data string) (bool, error) {\n    result := expensiveRegexCheck(data) && expensiveNetworkLookup(data)\n    return result, nil\n}\n```\n\n=== CODE QUALITY PATTERNS ===\n\nüìù **Error Handling:**\n```go\n// ‚úÖ GOOD: Meaningful error messages\nfunc Eval(ipStr string) (bool, error) {\n    ip := net.ParseIP(ipStr)\n    if ip == nil {\n        return false, fmt.Errorf(\"invalid IP address format: %s\", ipStr)\n    }\n    \n    // Check if it's a private IP\n    return ip.IsPrivate(), nil\n}\n\n// ‚ùå BAD: Generic or missing error context\nfunc Eval(ipStr string) (bool, error) {\n    ip := net.ParseIP(ipStr)\n    if ip == nil {\n        return false, errors.New(\"error\") // Too generic\n    }\n    return ip.IsPrivate(), nil\n}\n```\n\nüß™ **Input Validation:**\n```go\nfunc Eval(args ...interface{}) (bool, error) {\n    // Validate argument count\n    if len(args) == 0 {\n        return false, fmt.Errorf(\"plugin requires at least 1 argument\")\n    }\n    \n    // Validate argument types\n    strArg, ok := args[0].(string)\n    if !ok {\n        return false, fmt.Errorf(\"first argument must be string, got %T\", args[0])\n    }\n    \n    // Your logic here\n    return process(strArg), nil\n}\n```\n\n=== COMMON PATTERNS ===\n\nüîç **Pattern: String Matching Plugin**\n```go\npackage plugin\n\nimport (\n    \"regexp\"\n    \"strings\"\n)\n\nfunc Eval(data string) (bool, error) {\n    // Normalize input\n    data = strings.ToLower(strings.TrimSpace(data))\n    \n    // Multiple conditions\n    suspiciousPatterns := []string{\n        \"malware\",\n        \"trojan\",\n        \"backdoor\",\n    }\n    \n    for _, pattern := range suspiciousPatterns {\n        if strings.Contains(data, pattern) {\n            return true, nil\n        }\n    }\n    \n    return false, nil\n}\n```\n\nüåê **Pattern: Network Validation Plugin**\n```go\npackage plugin\n\nimport (\n    \"net\"\n    \"strings\"\n)\n\nfunc Eval(ipStr string) (bool, error) {\n    ipStr = strings.TrimSpace(ipStr)\n    \n    // Parse IP address\n    ip := net.ParseIP(ipStr)\n    if ip == nil {\n        return false, nil // Invalid IP is not local (fail safe)\n    }\n    \n    // Check various private ranges\n    return ip.IsPrivate() || ip.IsLoopback(), nil\n}\n```\n\nüìä **Pattern: Data Processing Plugin**\n```go\npackage plugin\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc Eval(oriData map[string]interface{}) (map[string]interface{}, error) {\n    if oriData == nil {\n        return nil, fmt.Errorf(\"input data cannot be nil\")\n    }\n    \n    // Create copy to avoid modifying original\n    result := make(map[string]interface{})\n    for k, v := range oriData {\n        result[k] = v\n    }\n    \n    // Add computed fields\n    if score, exists := result[\"raw_score\"]; exists {\n        if scoreFloat, err := strconv.ParseFloat(fmt.Sprintf(\"%v\", score), 64); err == nil {\n            result[\"threat_level\"] = calculateThreatLevel(scoreFloat)\n        }\n    }\n    \n    return result, nil\n}\n\nfunc calculateThreatLevel(score float64) string {\n    if score > 0.8 {\n        return \"high\"\n    } else if score > 0.5 {\n        return \"medium\"\n    }\n    return \"low\"\n}\n```\n\n=== TESTING STRATEGIES ===\n\nüß™ **Test Edge Cases:**\n- Empty strings: \"\"\n- Nil values: nil\n- Very long strings: strings > 1000 chars\n- Special characters: Unicode, escape sequences\n- Malformed data: invalid JSON, corrupted formats\n\nüß™ **Test Different Data Types:**\n```go\n// Test various input types for variadic functions\ntest_plugin with data: [\"string_input\"]\ntest_plugin with data: [123]\ntest_plugin with data: [true]\ntest_plugin with data: [\"string\", 456, false]\n```\n\n=== DEPLOYMENT BEST PRACTICES ===\n\nüöÄ **Pre-Deployment Checklist:**\n1. ‚úÖ Test plugin with 'test_plugin' tool\n2. ‚úÖ Validate with various input types\n3. ‚úÖ Check error handling with invalid inputs\n4. ‚úÖ Verify return types match intended usage\n5. ‚úÖ Test integration in development ruleset\n6. ‚úÖ Performance test with high-volume data\n\nüöÄ **Deployment Process:**\n1. Create plugin in temporary state\n2. Thorough testing with 'test_plugin'\n3. Integration testing with test rulesets\n4. 'apply_changes' only after validation\n5. Monitor system performance after deployment\n\nüìà **Performance Monitoring:**\n- Monitor CPU usage after plugin deployment\n- Check memory consumption patterns\n- Validate throughput impact\n- Set up alerts for plugin execution failures\n\nRemember: Well-designed plugins are the foundation of effective security rules!"
    }
  ],
  "rule_creation_warnings": {
    "pre_creation": "‚ö†Ô∏è Rule creation requires real sample data. Use get_samplers_data first or provide your own real data.",
    "data_validation": "‚úÖ Verify all field names and values exist in your actual data before creating rules.",
    "forbidden_actions": "‚ùå Never use imagined data like 'data_type=59' or 'exe=msfconsole' unless they appear in real samples."
  },
  "data_sources": {
    "allowed": [
      "MCP Server: get_samplers_data response",
      "MCP Server: get_samplers_data_intelligent response", 
      "User Provided: Real JSON from user's actual systems"
    ],
    "forbidden": [
      "AI imagination or assumptions",
      "Example/fake data creation",
      "Field name guessing",
      "Value fabrication"
    ]
  },
  "plugin_development": {
    "package_requirement": "package plugin  // MANDATORY",
    "function_requirement": "func Eval(...) (...)  // MANDATORY",
    "import_restrictions": "Only Go standard library allowed",
    "return_types": {
      "checknode": "(bool, error)",
      "data_processing": "(interface{}, bool, error) or (map[string]interface{}, error)"
    },
    "common_imports": [
      "strings",
      "regexp", 
      "fmt",
      "strconv",
      "time",
      "net",
      "encoding/json"
    ]
  }
} 